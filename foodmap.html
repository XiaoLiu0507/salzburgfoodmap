<!DOCTYPE html>
<html>
<head>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <script src="https://unpkg.com/mapbox-gl-leaflet/MapboxGLLeaflet.min.js"></script>
    <meta charset="UTF-8">
    <title>Where to Eat in Salzburg?</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="icon" type="image/png" href="icon.png">
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        /* Header style */
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #f3722c;
            color: white;
            text-align: center;
            padding: 20px 0;
            font-size: 24px;
            font-family: "Comic Sans MS", "Bradley Hand", cursive;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        /* Map container */
        #map {
            width: 100%;
            height: 100vh;
        }

        /* Category buttons container */
        #category-buttons {
            position: absolute;
            top: 80px;
            left: 10px;
            width: 200px;
            max-height: calc(100% - 100px);
            overflow-y: auto;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
        }

        /* Restaurant list container */
        #restaurant-list {
            position: absolute;
            top: 80px;
            left: 235px;
            width: 350px;
            max-height: calc(100% - 100px);
            overflow-y: auto;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
            display: none;
        }

        /* Category button style */
        .category-button {
            display: block;
            margin: 5px 0;
            padding: 5px;
            background-color: #f3722c; /* Default orange for category buttons */
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: "Comic Sans MS", "Bradley Hand", cursive;
        }

        /* Category button hover style */
        .category-button:hover {
            background-color: #0056b3;
        }

        /* Active category button style */
        .active {
            background-color: #007bff;
        }

        /* 
           Override the background color for "Show All" and 
           "Show Favorites" buttons to red (#FF0000)
        */
        #show-all-button.category-button,
        #show-favorites-button.category-button {
            background-color: #FF0000; /* Red color */
        }
        #show-all-button.category-button:hover,
        #show-favorites-button.category-button:hover {
            background-color: #0056b3; /* Deep blue on hover */
        }
        #show-all-button.category-button.active,
        #show-favorites-button.category-button.active {
            background-color: #007bff;
        }
        #show-all-button.category-button.active:hover,
        #show-favorites-button.category-button.active:hover {
            background-color: #0056b3;
        }

        /* Single restaurant item in the list */
        .restaurant-item {
            margin: 10px 0;
            padding: 5px;
            display: flex;
            align-items: center;
            font-family: "Comic Sans MS", "Bradley Hand", cursive;
            cursor: pointer;
        }

        /* Hover effect for a restaurant item */
        .restaurant-item:hover {
            background-color: #f0f0f0;
        }

        /* Rating bar container */
        .rating-bar {
            height: 20px;
            margin-left: 10px;
            flex-grow: 1;
            position: relative;
            background-color: #f0f0f0;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-right: 5px;
        }

        /* Filled part of the rating bar */
        .rating-fill {
            height: 100%;
            border-radius: 3px;
            width: 0;
            transition: width 0.3s;
        }

        /* Rating text inside the bar */
        .rating-text {
            color: black;
            font-size: 14px;
            margin-left: 5px;
            z-index: 2;
        }

        /* Popup style */
        .leaflet-popup-content {
            font-family: "Comic Sans MS", "Bradley Hand", cursive;
            font-size: 14px;
            color: black;
        }
        .leaflet-popup-content-wrapper {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .leaflet-popup-tip {
            background-color: white;
        }

        /* Leaflet layers control style */
        .leaflet-control-layers {
            font-family: "Comic Sans MS", "Bradley Hand", cursive;
            font-size: 14px;
            color: black;
            bottom: 10px;
            right: 0px;
            width: auto;
            height: auto;
        }

        /* Locate button style */
        #locate-button {
            position: absolute;
            bottom: 165px;
            right: 10px;
            z-index: 1000;
            width: 30px;
            height: 30px;
            background: #fff;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            background-image: url("locate.png");
            background-repeat: no-repeat;
            background-position: center;
            background-size: 20px 20px;
            cursor: pointer;
        }
        #locate-button:hover {
            background-color: #0056b3;
        }

        /* Search box container (top right corner) */
        #search-container {
            position: absolute;
            top: 80px;
            right: 10px;
            z-index: 1500;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 5px; /* Gap between search input and button */
        }
        #search-input {
            width: 150px;
            padding: 5px;
            font-family: "Comic Sans MS", "Bradley Hand", cursive;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        /* Autocomplete drop-down list */
        #autocomplete-list {
            position: absolute;
            top: 45px; /* Adjust based on actual input height */
            right: 80;
            width: 225px;
            list-style-type: none;
            margin: 0;
            padding: 0;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 3px;
            z-index: 2000;
            max-height: 200px;
            overflow-y: auto;
        }
        #autocomplete-list li {
            padding: 5px;
            cursor: pointer;
            font-family: "Comic Sans MS", cursive;
        }
        #autocomplete-list li:hover {
            background-color: #f0f0f0;
        }

        /* Search button style */
        #search-button {
            font-family: "Comic Sans MS", "Bradley Hand", cursive;
            font-size: 16px;
            color: #333;
            padding: 3px 5px; /* Button padding */
            border: 1px solid #ccc; /* Border */
            border-radius: 3px; /* Border-radius */
        }
        #search-button:hover {
            background-color: #ddd;
        }

        /* Default marker icon style (applies to all leaflet markers) */
        .leaflet-marker-icon {
            cursor: url('custom-cursor.png'), auto; /* Custom mouse cursor */
            transition: transform 0.3s ease, box-shadow 0.3s ease; /* Animation transition */
        }

        /* Hover effect for marker icons (enlarge on hover) */
        .leaflet-marker-icon:hover {
            cursor: url('fork.png'), auto;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="header">üçîWhere to Eat in Salzburg?</div>
    
    <!-- Search box container (including a search button and autocomplete list) -->
    <div id="search-container">
        <input type="text" id="search-input" placeholder="Search restaurants..." />
        <button id="search-button">Search</button>
        <ul id="autocomplete-list" style="display: none;"></ul>
    </div>

    <div id="map"></div>
    <div id="category-buttons"></div>
    <div id="restaurant-list"></div>

    <!-- Locate button DOM -->
    <div id="locate-button"></div>

    <script>
        // List of categories
        const categories = [
            "African cuisine", "Japanese cuisine", "Italian cuisine", "Mexican cuisine",
            "Austrian cuisine", "Chinese cuisine", "Greek cuisine", "Nepalese cuisine",
            "Thai cuisine", "Croatian cuisine", "American fast food", "Indian cuisine",
            "Hawaiian cuisine", "Turkish cuisine", "Argentinian cuisine", "Vietnamese cuisine",
            "Sri Lankan cuisine", "Arabic cuisine", "Polish cuisine", "Korean cuisine",
            "Peruvian cuisine", "Portuguese cuisine"
        ].sort();

        // Mapping each category to a flag image
        const flagIcons = {
            "African cuisine": "flags/africa.png",
            "Japanese cuisine": "flags/japan.png",
            "Italian cuisine": "flags/italy.png",
            "Mexican cuisine": "flags/mexico.png",
            "Austrian cuisine": "flags/austria.png",
            "Chinese cuisine": "flags/china.png",
            "Greek cuisine": "flags/greece.png",
            "Nepalese cuisine": "flags/nepal.png",
            "Thai cuisine": "flags/thailand.png",
            "Croatian cuisine": "flags/croatia.png",
            "American fast food": "flags/usa.png",
            "Indian cuisine": "flags/india.png",
            "Hawaiian cuisine": "flags/hawaii.png",
            "Turkish cuisine": "flags/turkey.png",
            "Argentinian cuisine": "flags/argentina.png",
            "Vietnamese cuisine": "flags/vietnam.png",
            "Sri Lankan cuisine": "flags/sri_lanka.png",
            "Arabic cuisine": "flags/arab_league.png",
            "Polish cuisine": "flags/poland.png",
            "Korean cuisine": "flags/korea.png",
            "Peruvian cuisine": "flags/peru.png",
            "Portuguese cuisine": "flags/portugal.png"
        };

        // Store all restaurant data and marker references
        let allRestaurantData = [];
        let allMarkers = [];
        const markersByCategory = {};

        // NEW: Keep track of user favorites in a Set (by restaurant name or unique ID)
        const myFavorites = new Set();

        // Helper function to build popup HTML, including the favorite star
        function getPopupContent(name, type, rating, user_ratings_total) {
            const isFav = myFavorites.has(name);
            // If restaurant is already in favorites, show a filled star (‚òÖ); otherwise an empty star (‚òÜ)
            const star = isFav ? "‚òÖ" : "‚òÜ";

            return `
                <div>
                    <strong>${name}</strong>
                    <button class="favorite-star"
                            data-name="${name}"
                            style="background:none; border:none; cursor:pointer; font-size:18px; margin-left:8px;">
                        ${star}
                    </button>
                    <br>
                    Type: ${type}<br>
                    Rating: ${rating} (${user_ratings_total} reviews)
                </div>
            `;
        }

        // Toggle favorite status
        function toggleFavorite(name, starElement) {
            if (myFavorites.has(name)) {
                myFavorites.delete(name);
                starElement.textContent = '‚òÜ'; // Not favorite
            } else {
                myFavorites.add(name);
                starElement.textContent = '‚òÖ'; // Favorite
            }
        }

        // Handle clicks on the star inside popups (global approach)
        document.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('favorite-star')) {
                const restaurantName = e.target.getAttribute('data-name');
                toggleFavorite(restaurantName, e.target);
            }
        });

        // Define map bounds around Salzburg
        const salzburgBounds = [
            [47.67, 12.90],
            [47.95, 13.20]
        ];

        // Initialize map
        const map = L.map('map', {
            zoomControl: false,
            maxBounds: salzburgBounds,
            maxBoundsViscosity: 1.0,
            minZoom: 13
        }).setView([47.8095, 13.0550], 13);

        // Base layers
        const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri'
        });

        // Layer control (street map vs satellite imagery)
        L.control.layers({
            'Street Map': streetLayer,
            'Satellite Imagery': satelliteLayer
        }, null, { position: 'bottomright' }).addTo(map);

        // Zoom control in the bottom right
        L.control.zoom({
            position: 'bottomright'
        }).addTo(map);

        // Fetch restaurant data and display markers
        fetch('restaurants_in_salzburg2.json')
            .then(response => response.json())
            .then(data => {
                // Save the raw data
                allRestaurantData = data;

                // Initialize each category's marker array
                categories.forEach(category => {
                    markersByCategory[category] = [];
                });

                // Create and store all markers
                data.forEach(restaurant => {
                    const { name, type, rating, user_ratings_total, latitude, longitude } = restaurant;
                    const iconUrl = flagIcons[type] || "flags/default.png";
                    const customIcon = L.icon({
                        iconUrl,
                        iconSize: [40, null], // You can adjust the size as needed
                        iconAnchor: [15, 30],
                        popupAnchor: [0, -30]
                    });

                    // Create marker 
                    const marker = L.marker([latitude, longitude], { icon: customIcon })
                        // Important: bind a blank popup first, so it automatically opens
                        .bindPopup("");

                    // When the popup truly opens, set actual content
                    marker.on('popupopen', () => {
                        marker.setPopupContent(
                            getPopupContent(name, type, rating, user_ratings_total)
                        );
                    });

                    // Attach restaurant data to the marker (useful for searching)
                    marker.restaurantData = { name, type, rating, user_ratings_total };

                    // Add the marker to the appropriate category array
                    if (markersByCategory[type]) {
                        markersByCategory[type].push(marker);
                    }
                    // Add to the overall marker array
                    allMarkers.push(marker);

                    // By default, add all markers to the map
                    marker.addTo(map);
                });

                // Initialize category buttons
                initCategoryButtons();
            })
            .catch(error => console.error('Error loading JSON:', error));

        // Initialize the category buttons
        function initCategoryButtons() {
            const categoryContainer = document.getElementById('category-buttons');

            // "Show All" button
            // Give it an ID so we can override its default color in CSS
            const showAllButton = document.createElement('div');
            showAllButton.id = 'show-all-button';            // Added ID
            showAllButton.className = 'category-button active';
            showAllButton.textContent = "Show All";
            showAllButton.onclick = () => {
                showAllRestaurants();
                setActiveButton(showAllButton);
            };
            categoryContainer.appendChild(showAllButton);

            // "Show Favorites" button
            // Give it an ID so we can override its default color in CSS
            const showFavoritesButton = document.createElement('div');
            showFavoritesButton.id = 'show-favorites-button'; // Added ID
            showFavoritesButton.className = 'category-button';
            showFavoritesButton.textContent = "Show Favorites";
            showFavoritesButton.onclick = () => {
                showFavorites();
                setActiveButton(showFavoritesButton);
            };
            categoryContainer.appendChild(showFavoritesButton);

            // Create a button for each category
            categories.forEach(category => {
                const button = document.createElement('div');
                button.className = 'category-button';
                button.textContent = category;
                button.onclick = () => {
                    filterByCategory(category);
                    setActiveButton(button);
                };
                categoryContainer.appendChild(button);
            });
        }

        // Show favorites only
        function showFavorites() {
            const restaurantList = document.getElementById('restaurant-list');
            restaurantList.style.display = 'block';
            restaurantList.innerHTML = '';

            clearMarkersFromMap();

            // Filter markers that are in myFavorites
            const favoriteMarkers = allMarkers.filter(marker =>
                myFavorites.has(marker.restaurantData.name)
            );

            // Sort by rating (descending)
            favoriteMarkers.sort((a, b) => {
                const ratingA = parseFloat(a.restaurantData.rating) || 0;
                const ratingB = parseFloat(b.restaurantData.rating) || 0;
                return ratingB - ratingA;
            });

            // Add them to the map and build the side list
            favoriteMarkers.forEach(marker => {
                marker.addTo(map);
                const item = createRestaurantItem(marker);
                restaurantList.appendChild(item);
            });

            // Adjust the map view
            if (favoriteMarkers.length > 0) {
                const group = new L.featureGroup(favoriteMarkers);
                map.fitBounds(group.getBounds());
            } else {
                restaurantList.innerHTML = '<p style="font-family: Comic Sans MS, Bradley Hand, cursive; font-size: 16px; color: #333; text-align: center; margin: 10px 0;">No favorites yet.</p>';
            }
        }

        // Filter markers by category
        function filterByCategory(category) {
            const restaurantList = document.getElementById('restaurant-list');
            restaurantList.style.display = 'block';

            clearMarkersFromMap();

            // Get all markers in this category
            const selectedMarkers = markersByCategory[category];

            // Clear the right-hand restaurant list
            restaurantList.innerHTML = '';

            // Sort by rating (descending) and display
            selectedMarkers
                .sort((a, b) => {
                    const ratingA = parseFloat(a.restaurantData.rating) || 0;
                    const ratingB = parseFloat(b.restaurantData.rating) || 0;
                    return ratingB - ratingA;
                })
                .forEach(marker => {
                    marker.addTo(map);
                    const item = createRestaurantItem(marker);
                    restaurantList.appendChild(item);
                });

            // Adjust the map view to fit these markers
            if (selectedMarkers.length > 0) {
                const group = new L.featureGroup(selectedMarkers);
                map.fitBounds(group.getBounds());
            }
        }

        // Show all markers
        function showAllRestaurants() {
            const restaurantList = document.getElementById('restaurant-list');
            restaurantList.style.display = 'none';

            clearMarkersFromMap();
            allMarkers.forEach(marker => marker.addTo(map));

            if (allMarkers.length > 0) {
                const group = new L.featureGroup(allMarkers);
                map.fitBounds(group.getBounds());
            }
        }

        // Remove all markers from the map
        function clearMarkersFromMap() {
            allMarkers.forEach(marker => {
                if (map.hasLayer(marker)) {
                    map.removeLayer(marker);
                }
            });
        }

        // Highlight the active category button
        function setActiveButton(activeButton) {
            const buttons = document.querySelectorAll('.category-button');
            buttons.forEach(button => button.classList.remove('active'));
            activeButton.classList.add('active');
        }

        // Create a restaurant list item DOM element
        function createRestaurantItem(marker) {
            const { name, rating } = marker.restaurantData;
            const item = document.createElement('div');
            item.className = 'restaurant-item';

            // Decide the color of the rating bar based on the rating
            let barColor = 'red';
            if (rating >= 4) {
                barColor = 'green';
            } else if (rating >= 3) {
                barColor = 'orange';
            }

            item.innerHTML = 
                `<span>${name}</span>
                <div class="rating-bar">
                    <div class="rating-fill" style="width: ${rating * 20}%; background-color: ${barColor};"></div>
                    <div class="rating-text">${parseFloat(rating).toFixed(1)}</div>
                </div>`;

            // On click, center the map on this marker and open the popup
            item.onclick = () => {
                map.setView(marker.getLatLng(), 15);
                marker.openPopup();
            };
            return item;
        }

        // Fetch and display Salzburg boundary
        fetch('salzburg_boundary.geojson')
            .then(response => response.json())
            .then(boundaryData => {
                const boundaryLayer = L.geoJSON(boundaryData, {
                    style: {
                        color: "#ff7800",
                        weight: 2,
                        opacity: 1.0,
                        fillOpacity: 0.1
                    }
                }).addTo(map);

                const boundaryBounds = boundaryLayer.getBounds();
                map.fitBounds(boundaryBounds);
            })
            .catch(error => console.error('Error loading Salzburg boundary:', error));

        // Locate button functionality
        const locateButton = document.getElementById('locate-button');
        locateButton.addEventListener('click', () => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        map.setView([latitude, longitude], 15);
                        L.marker([latitude, longitude])
                            .addTo(map)
                            .bindPopup("You are here.")
                            .openPopup();
                    },
                    (error) => {
                        alert("Could not get your location: " + error.message);
                    }
                );
            } else {
                alert("Your browser does not support geolocation.");
            }
        });

        // ================== Autocomplete + Search ==================

        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const autocompleteList = document.getElementById('autocomplete-list');

        // Global variable to track the current focus in the autocomplete list
        let currentFocus = -1;

        // Add event listener to "Search" button
        searchButton.addEventListener('click', handleSearch);

        // Add event listener to search input for "Enter" and navigation keys
        searchInput.addEventListener('keydown', (event) => {
            const items = autocompleteList.querySelectorAll('li');
            if (event.key === 'ArrowDown') {
                // Move focus to the next item
                currentFocus++;
                highlightOption(items);
                event.preventDefault();
            } else if (event.key === 'ArrowUp') {
                // Move focus to the previous item
                currentFocus--;
                highlightOption(items);
                event.preventDefault();
            } else if (event.key === 'Enter') {
                // Select the current highlighted item or trigger a search
                event.preventDefault();
                if (currentFocus > -1 && items[currentFocus]) {
                    searchInput.value = items[currentFocus].textContent; // Fill input
                    autocompleteList.style.display = 'none';
                }
                handleSearch();
            }
        });

        // Display autocomplete suggestions as user types
        searchInput.addEventListener('input', () => {
            const query = searchInput.value.trim().toLowerCase();
            autocompleteList.innerHTML = '';
            currentFocus = -1;

            if (!query) {
                autocompleteList.style.display = 'none';
                return;
            }

            // Fuzzy match based on restaurant name
            const suggestions = allRestaurantData
                .map(r => r.name)
                .filter(name => name.toLowerCase().includes(query))
                .slice(0, 10);

            if (suggestions.length === 0) {
                autocompleteList.style.display = 'none';
                return;
            }

            // Generate the drop-down list
            suggestions.forEach(name => {
                const li = document.createElement('li');
                li.textContent = name;
                li.addEventListener('click', () => {
                    searchInput.value = name;
                    autocompleteList.style.display = 'none';
                });
                autocompleteList.appendChild(li);
            });
            autocompleteList.style.display = 'block';
        });

        // Encapsulate the search functionality into a reusable function
        function handleSearch() {
            const query = searchInput.value.trim().toLowerCase();

            if (!query) {
                alert('Please enter a restaurant name to search!');
                return;
            }

            // Find markers whose names match the query
            const matchedMarkers = allMarkers.filter(marker =>
                marker.restaurantData.name.toLowerCase().includes(query)
            );

            if (matchedMarkers.length === 0) {
                alert('No matching restaurants found.');
                return;
            }

            // Clear existing markers and display only matched markers on the map
            clearMarkersFromMap();
            matchedMarkers.forEach(marker => marker.addTo(map));

            // Adjust map view to fit the matched markers
            const group = L.featureGroup(matchedMarkers);
            map.fitBounds(group.getBounds());

            // Update the right-hand restaurant list
            updateRestaurantList(matchedMarkers);
        }

        // Function to update the restaurant list on the right-hand side
        function updateRestaurantList(matchedMarkers) {
            const restaurantList = document.getElementById('restaurant-list');
            restaurantList.innerHTML = '';
            restaurantList.style.display = 'block';

            // Sort matched markers by rating in descending order
            matchedMarkers.sort((a, b) => {
                const ratingA = parseFloat(a.restaurantData.rating) || 0;
                const ratingB = parseFloat(b.restaurantData.rating) || 0;
                return ratingB - ratingA;
            });

            // Create and append restaurant items to the list
            matchedMarkers.forEach(marker => {
                const item = createRestaurantItem(marker);
                restaurantList.appendChild(item);
            });
        }

        // Function to highlight the currently focused autocomplete item
        function highlightOption(items) {
            // Remove highlight from all items
            items.forEach(item => item.classList.remove('autocomplete-active'));

            // Loop focus index if out of bounds
            if (currentFocus >= items.length) currentFocus = 0;
            if (currentFocus < 0) currentFocus = items.length - 1;

            // Highlight the currently focused item and update input
            if (items[currentFocus]) {
                items[currentFocus].classList.add('autocomplete-active');
                searchInput.value = items[currentFocus].textContent;
                items[currentFocus].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Additional custom CSS for autocomplete highlight
        const style = document.createElement('style');
        style.innerHTML = `
        #autocomplete-list li {
            padding: 10px;
            cursor: pointer;
            list-style: none;
        }
        #autocomplete-list li:hover, #autocomplete-list li.autocomplete-active {
            background-color: #f3722c;
            color: white;
        }
        `;
        document.head.appendChild(style);

        // ================== End Autocomplete + Search ==================

    </script>
</body>
</html>
